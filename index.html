<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Points Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 3px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        button.active {
            background: #FF6B35;
        }
        
        button.active:hover {
            background: #E55A2B;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        #info {
            margin-top: 10px;
            font-size: 12px;
        }
        
        #orientation-gizmo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="orientation-gizmo"></div>
    <div id="controls">
        <div>
            <button id="playBtn">Play</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
        <div>
            <label>Cross Section:</label><br>
            <button id="fullBtn" class="active">Full</button>
            <button id="horizontalBtn">Horizontal</button>
            <button id="verticalBtn">Vertical</button>
        </div>
        <div>
            <label>Time Frame: <span id="frameLabel">1 / 120</span></label><br>
            <input type="range" id="timeSlider" min="0" max="119" value="0">
        </div>
        <div>
            <label>Speed: <span id="speedLabel">1.0x</span></label><br>
            <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1.0">
        </div>
        <div id="info">
            <div>Points: 5000</div>
            <div>Total Frames: 120</div>
            <div>Use mouse to rotate, scroll to zoom</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, points;
        let gizmoScene, gizmoCamera, gizmoRenderer;
        let controls; // OrbitControls
        let pointsData = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationSpeed = 1.; // Slower default speed
        let lastTime = 0;
        let crossSectionMode = 'full'; // 'full', 'horizontal', 'vertical'
        
        // Controls
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const timeSlider = document.getElementById('timeSlider');
        const speedSlider = document.getElementById('speedSlider');
        const frameLabel = document.getElementById('frameLabel');
        const speedLabel = document.getElementById('speedLabel');
        const fullBtn = document.getElementById('fullBtn');
        const horizontalBtn = document.getElementById('horizontalBtn');
        const verticalBtn = document.getElementById('verticalBtn');

        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 120); // Start looking straight down Z-axis, more zoomed out
            camera.lookAt(0, 0, 0);

            // Add lighting for the 3D spheres
            const ambientLight = new THREE.AmbientLight(0x606060, 1.2); // Brighter ambient light
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(50, 50, 50);
            scene.add(directionalLight1);
            
            // Add a second directional light from a different angle
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-50, 30, -30);
            scene.add(directionalLight2);
            
            // Add a third light from below for better illumination
            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight3.position.set(0, -50, 0);
            scene.add(directionalLight3);
            
            // Add additional lights for better coverage
            const directionalLight4 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight4.position.set(30, -30, 50);
            scene.add(directionalLight4);
            
            const directionalLight5 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight5.position.set(-30, 50, -50);
            scene.add(directionalLight5);
            
            // Add a point light for additional fill lighting
            const pointLight = new THREE.PointLight(0xffffff, 0.6, 200);
            pointLight.position.set(0, 30, 30);
            scene.add(pointLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Create orientation gizmo
            createOrientationGizmo();

            // Setup OrbitControls
            setupOrbitControls();

            // Load and parse CSV data
            loadCSVData();

            // Event listeners
            setupEventListeners();

            // Start render loop
            animate();
        }

        function setupOrbitControls() {
            // Create OrbitControls for smooth camera movement
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            // Configure controls for statue-like viewing
            controls.target.set(0, 0, 0); // Look at center of the points
            controls.enableDamping = true; // Smooth motion
            controls.dampingFactor = 0.05;
            
            // Prevent rolling - keep camera upright
            controls.enableRotate = true;
            controls.rotateSpeed = 0.5;
            
            // Allow zooming
            controls.enableZoom = true;
            controls.zoomSpeed = 1.0;
            controls.minDistance = 15;  // Don't get too close
            controls.maxDistance = 300; // Don't get too far
            
            
            // Allow panning (optional - you might want to disable this)
            controls.enablePan = false; // Disable panning to keep focused on statue
            
            // Vertical rotation limits (prevent going under the statue)
            controls.minPolarAngle = 0.1; // Radians from top
            controls.maxPolarAngle = Math.PI - 0.1; // Radians from top
            
            // Update controls on change
            controls.addEventListener('change', () => {
                updateGizmoOrientation();
            });
            
            // Set initial position
            camera.position.set(0, 0, -120); // Looking straight down Z-axis, more zoomed out
            controls.update();
        }

        function createOrientationGizmo() {
            // Create separate scene and camera for the gizmo
            gizmoScene = new THREE.Scene();
            gizmoCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            gizmoCamera.position.set(0, 0, 5);

            // Create the gizmo renderer
            gizmoRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            gizmoRenderer.setSize(80, 80);
            gizmoRenderer.setClearColor(0x000000, 0.1); // Semi-transparent background
            document.getElementById('orientation-gizmo').appendChild(gizmoRenderer.domElement);

            // Create axis arrows
            const axisLength = 1.5;
            const arrowHeadLength = 0.3;
            const arrowHeadWidth = 0.15;

            // X-axis (Red)
            const xAxisGroup = new THREE.Group();
            const xGeometry = new THREE.CylinderGeometry(0.02, 0.02, axisLength, 8);
            const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xArrow = new THREE.Mesh(xGeometry, xMaterial);
            xArrow.rotation.z = -Math.PI / 2;
            xArrow.position.x = axisLength / 2;
            
            const xHeadGeometry = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const xHead = new THREE.Mesh(xHeadGeometry, xMaterial);
            xHead.rotation.z = -Math.PI / 2;
            xHead.position.x = axisLength + arrowHeadLength / 2;
            
            xAxisGroup.add(xArrow);
            xAxisGroup.add(xHead);
            gizmoScene.add(xAxisGroup);

            // Y-axis (Green)
            const yAxisGroup = new THREE.Group();
            const yGeometry = new THREE.CylinderGeometry(0.02, 0.02, axisLength, 8);
            const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yArrow = new THREE.Mesh(yGeometry, yMaterial);
            yArrow.position.y = axisLength / 2;
            
            const yHeadGeometry = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const yHead = new THREE.Mesh(yHeadGeometry, yMaterial);
            yHead.position.y = axisLength + arrowHeadLength / 2;
            
            yAxisGroup.add(yArrow);
            yAxisGroup.add(yHead);
            gizmoScene.add(yAxisGroup);

            // Z-axis (Blue)
            const zAxisGroup = new THREE.Group();
            const zGeometry = new THREE.CylinderGeometry(0.02, 0.02, axisLength, 8);
            const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zArrow = new THREE.Mesh(zGeometry, zMaterial);
            zArrow.rotation.x = Math.PI / 2;
            zArrow.position.z = axisLength / 2;
            
            const zHeadGeometry = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const zHead = new THREE.Mesh(zHeadGeometry, zMaterial);
            zHead.rotation.x = Math.PI / 2;
            zHead.position.z = axisLength + arrowHeadLength / 2;
            
            zAxisGroup.add(zArrow);
            zAxisGroup.add(zHead);
            gizmoScene.add(zAxisGroup);

            // Store references for rotation updates
            gizmoScene.userData.xAxis = xAxisGroup;
            gizmoScene.userData.yAxis = yAxisGroup;
            gizmoScene.userData.zAxis = zAxisGroup;
        }

        function updateGizmoOrientation() {
            if (!gizmoScene) return;
            
            // Create a rotation matrix that matches the main camera's orientation
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Set gizmo camera to look from the same direction as main camera
            gizmoCamera.position.copy(cameraDirection).multiplyScalar(-5);
            gizmoCamera.lookAt(0, 0, 0);
        }

        async function loadCSVData() {
            try {
                const response = await fetch('toshow.csv');
                const csvText = await response.text();
                
                const lines = csvText.trim().split('\n');
                const totalPoints = 5000;
                const totalFrames = 120;
                
                // Parse CSV data into frames
                for (let frame = 0; frame < totalFrames; frame++) {
                    const frameData = [];
                    for (let point = 0; point < totalPoints; point++) {
                        const lineIndex = frame * totalPoints + point;
                        if (lineIndex < lines.length) {
                            const coords = lines[lineIndex].split(',').map(Number);
                            frameData.push(coords[0], coords[1], coords[2]); // x, y, z
                        }
                    }
                    pointsData.push(frameData);
                }
                
                console.log(`Loaded ${pointsData.length} frames with ${totalPoints} points each`);
                createPointCloud();
                
            } catch (error) {
                console.error('Error loading CSV:', error);
                alert('Error loading CSV file. Make sure toshow.csv is in the same directory.');
            }
        }

        function createPointCloud() {
            if (pointsData.length === 0) return;

            // Remove existing points
            if (points) {
                scene.remove(points);
            }

            // Create instanced mesh for spheres
            const sphereGeometry = new THREE.SphereGeometry(1.5, 8, 6); // Larger spheres 
            const sphereMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888, // Grey color
            });

            points = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, 5000);
            
            // Set initial positions
            updateInstancedMeshPositions(0);
            
            scene.add(points);

            updateFrameDisplay();
        }

        function updateInstancedMeshPositions(frame) {
            if (!points || !pointsData[frame]) return;
            
            const frameData = pointsData[frame];
            const matrix = new THREE.Matrix4();
            let visibleCount = 0;
            
            for (let i = 0; i < 5000; i++) {
                const x = frameData[i * 3];
                const y = frameData[i * 3 + 1];
                const z = frameData[i * 3 + 2];
                
                // Rotate 90 degrees around X-axis: (x, y, z) -> (x, -z, y)
                const rotatedX = -x;
                const rotatedY = z;
                const rotatedZ = y;
                
                // Check cross-section visibility
                let isVisible = true;
                if (crossSectionMode === 'horizontal') {
                    // Show only points where X > 0 (horizontal cross-section)
                    isVisible = rotatedX < 0;
                } else if (crossSectionMode === 'vertical') {
                    // Show only points where Z > 0 (vertical cross-section)
                    isVisible = rotatedZ > 0;
                }
                
                if (isVisible) {
                    matrix.setPosition(rotatedX, rotatedY, rotatedZ);
                    points.setMatrixAt(visibleCount, matrix);
                    visibleCount++;
                }
            }
            
            // Hide remaining instances by setting them far away
            const hiddenMatrix = new THREE.Matrix4();
            hiddenMatrix.setPosition(10000, 10000, 10000); // Far away position
            for (let i = visibleCount; i < 5000; i++) {
                points.setMatrixAt(i, hiddenMatrix);
            }
            
            points.instanceMatrix.needsUpdate = true;
        }

        function updateFrame(frame) {
            if (!points || !pointsData[frame]) return;
            
            updateInstancedMeshPositions(frame);
            
            currentFrame = frame;
            timeSlider.value = frame;
            updateFrameDisplay();
        }

        function updateFrameDisplay() {
            frameLabel.textContent = `${currentFrame + 1} / 120`;
        }

        function setupEventListeners() {
            playBtn.addEventListener('click', () => {
                isPlaying = true;
                playBtn.disabled = true;
                pauseBtn.disabled = false;
            });

            pauseBtn.addEventListener('click', () => {
                isPlaying = false;
                playBtn.disabled = false;
                pauseBtn.disabled = true;
            });

            resetBtn.addEventListener('click', () => {
                currentFrame = 0;
                if (points && pointsData.length > 0) {
                    updateInstancedMeshPositions(0);
                }
                updateFrameDisplay();
                isPlaying = false;
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                
                // Reset camera position and controls
                camera.position.set(0, 0, 120);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            timeSlider.addEventListener('input', (e) => {
                currentFrame = parseInt(e.target.value);
                updateFrame(currentFrame);
            });

            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                speedLabel.textContent = `${animationSpeed.toFixed(1)}x`;
            });

            // Cross-section buttons
            fullBtn.addEventListener('click', () => {
                setCrossSectionMode('full');
            });

            horizontalBtn.addEventListener('click', () => {
                setCrossSectionMode('horizontal');
            });

            verticalBtn.addEventListener('click', () => {
                setCrossSectionMode('vertical');
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setCrossSectionMode(mode) {
            crossSectionMode = mode;
            
            // Update button states
            fullBtn.classList.toggle('active', mode === 'full');
            horizontalBtn.classList.toggle('active', mode === 'horizontal');
            verticalBtn.classList.toggle('active', mode === 'vertical');
            
            // Update the current frame to apply the cross-section
            if (points && pointsData.length > 0) {
                updateInstancedMeshPositions(currentFrame);
            }
        }

        function animate(time = 0) {
            requestAnimationFrame(animate);

            // Update OrbitControls for smooth damping
            if (controls) {
                controls.update();
            }

            // Animation logic
            if (isPlaying && pointsData.length > 0) {
                const deltaTime = time - lastTime;
                if (deltaTime >= (2000 / (30 * animationSpeed))) { // 30 FPS adjusted by speed
                    currentFrame = (currentFrame + 1) % pointsData.length;
                    updateFrame(currentFrame);
                    lastTime = time;
                }
            }

            renderer.render(scene, camera);
            
            // Render the orientation gizmo
            if (gizmoRenderer && gizmoScene && gizmoCamera) {
                gizmoRenderer.render(gizmoScene, gizmoCamera);
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
